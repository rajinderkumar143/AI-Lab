import copy

# Each literal: (predicate, [args], is_negated)
# Example KB:
# 1. ¬Human(x) ∨ Mortal(x)
# 2. Human(Socrates)
# Query: Mortal(Socrates)

KB = [
    [('Human', ['x'], True), ('Mortal', ['x'], False)],
    [('Human', ['Socrates'], False)]
]

query = ('Mortal', ['Socrates'], False)


# ---------- Unification ----------
def unify(x, y, theta=None):
    if theta is None:
        theta = {}

    if x == y:
        return theta

    # variable x
    elif isinstance(x, str) and x.islower():
        return unify_var(x, y, theta)

    # variable y
    elif isinstance(y, str) and y.islower():
        return unify_var(y, x, theta)

    # lists (arguments)
    elif isinstance(x, list) and isinstance(y, list) and len(x) == len(y):
        for xi, yi in zip(x, y):
            theta = unify(xi, yi, theta)
            if theta is None:
                return None
        return theta

    # tuple literal → convert to list
    elif isinstance(x, tuple) and isinstance(y, tuple):
        return unify(list(x), list(y), theta)

    return None


def unify_var(var, x, theta):
    if var in theta:
        return unify(theta[var], x, theta)
    elif isinstance(x, str) and x in theta:
        return unify(var, theta[x], theta)
    else:
        theta[var] = x
        return theta


# ---------- Apply Substitution ----------
def substitute(clause, theta):
    new_clause = []
    for (pred, args, neg) in clause:
        new_args = [theta.get(a, a) for a in args]
        new_clause.append((pred, new_args, neg))
    return new_clause


# ---------- Resolution Step ----------
def resolve(ci, cj):
    resolvents = []

    for (pi, args_i, neg_i) in ci:
        for (pj, args_j, neg_j) in cj:

            # predicates match & opposite polarity
            if pi == pj and neg_i != neg_j:
                theta = unify(args_i, args_j)

                if theta is not None:
                    # remove resolved literals
                    new_ci = [lit for lit in ci if lit != (pi, args_i, neg_i)]
                    new_cj = [lit for lit in cj if lit != (pj, args_j, neg_j)]

                    merged = new_ci + new_cj

                    resolvent = substitute(merged, theta)

                    # remove duplicates
                    resolved_unique = []
                    for lit in resolvent:
                        if lit not in resolved_unique:
                            resolved_unique.append(lit)

                    resolvents.append(resolved_unique)

    return resolvents


# ---------- Full Resolution Procedure ----------
def resolution(KB, query):
    negated_query = [(query[0], query[1], not query[2])]
    clauses = KB + [negated_query]

    print("\nInitial clauses:")
    for c in clauses:
        print(" ", c)

    new = []

    while True:
        n = len(clauses)
        pairs = [(clauses[i], clauses[j]) for i in range(n) for j in range(i + 1, n)]

        for (ci, cj) in pairs:
            resolvents = resolve(ci, cj)

            for r in resolvents:
                if r == []:
                    print("\nDerived empty clause → Query proven")
                    return True

                if r not in new:
                    new.append(r)

        # Check if no progress
        if all(c in clauses for c in new):
            print("\nNo new clauses → Query cannot be proven")
            return False

        for c in new:
            if c not in clauses:
                clauses.append(c)


# ---------- MAIN ----------
if __name__ == "__main__":
    print("Proving:", query)
    result = resolution(KB, query)
    print("\nResult:", "Proved" if result else "Not Proved")
